# -- The initial number of Jira pods that should be started at deployment time. 
# Note: Jira requires manual configuration via the browser after the first pod is 
# deployed. This configuration must be completed before scaling up additional pods. 
# As such this value should always be kept as 1.
replicaCount: 1

# - Image configuration (OPTIONAL) ######################################################################################
image:
  # https://hub.docker.com/r/atlassian/jira-software
  repository: atlassian/jira-software 
  pullPolicy: IfNotPresent
  # -- The docker image tag to be used. Defaults to the Chart appVersion.
  tag: ""
  
# - Service configuration (OPTIONAL) ####################################################################################
serviceAccount:
  # -- Set to 'true' if a ServiceAccount should be created, or 'false' if it already exists
  create: true
  # -- The name of the ServiceAccount to be used by the pods. If not specified, but 
  # the "serviceAccount.create" flag is set to 'true', then the ServiceAccount name 
  # will be auto-generated, otherwise the 'default' ServiceAccount will be used.
  name:
  # -- The list of image pull secrets that should be added to the created ServiceAccount
  imagePullSecrets: []

# - Database configuration (REQUIRED FOR PRODUCTION) ####################################################################
# Jira requires a backend database. The configuration below can be used to define the database to use
# and its connection details. Additional detail:
# https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#database-connectivity
database: 
  # -- The database type that should be used
  # If not specified, then it will need to be provided via the browser during initial startup. 
  # Valid values include:
  # - 'postgres72'
  # - 'mysql57'
  # - 'mysql8'
  # - 'oracle10g'
  # - 'mssql'
  # - 'postgresaurora96'
  # Additional detail: 
  # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#databasetype
  type: 
  # -- The jdbc URL of the database
  # If not specified, then it will need to be provided via the browser during initial startup. 
  # Example URL's include:
  # - 'jdbc:postgresql://<dbhost>:5432/<dbname>'
  # - 'jdbc:mysql://<dbhost>/<dbname>'
  # - 'jdbc:sqlserver://<dbhost>:1433;databaseName=<dbname>'
  # - 'jdbc:oracle:thin:@<dbhost>:1521:<SID>'
  # Additional detail: 
  # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#databasejdbcurl
  url: 
  # -- The Java class name of the JDBC driver to be used, e.g. 'org.postgresql.Driver'
  # If not specified, then it will need to be provided via the browser during initial startup.
  # Additional detail:
  # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#databasedriver
  driver: 
  credentials:
    # -- The name of the Kubernetes Secret that contains the database login credentials.
    # If the secret is specified, then the credentials will be automatically utilised on 
    # Jira startup. If the secret is not provided, then the credentials will need to be provided 
    # via the browser during initial startup. Example of creating a Kubernetes secret below:
    # 'kubectl create secret generic <secret-name> --from-literal=username=<username> \
    # --from-literal=password=<password>'
    # Additional detail:
    # https://kubernetes.io/docs/concepts/configuration/secret/#opaque-secrets
    secretName: 
    # -- The key ('username') in the Secret used to store the database login username
    usernameSecretKey: username
    # -- The key ('password') in the Secret used to store the database login password
    passwordSecretKey: password

# - Volume configuration (REQUIRED FOR PRODUCTION) ######################################################################
# By default, the charts will configure the local-home and shared-home as ephemeral volumes i.e. 
# 'emptyDir: {}'. This is fine for evaluation purposes but for production deployments this is not 
# ideal and so local-home and shared-home should both be configured appropriately. Additional detail:
# https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#volumes-configuration
volumes:
  # -- A volume for local-home is required for key data that help define how Jira works. 
  localHome:
    # -- Dynamic provisioning. Additional detail: 
    # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/examples/storage/aws/LOCAL_STORAGE.md
    persistentVolumeClaim:
      # -- If 'true', then a 'PersistentVolumeClaim' and 'PersistentVolume' will be dynamically 
      # created for each pod based on the 'StorageClassName' supplied below.          
      create: false
      # -- Specifies the name of the 'StorageClass' that should be used for the local-home volume claim.
      storageClassName:
      # -- Specifies the standard Kubernetes resource requests and/or limits for the local-home volume claims.
      resources:
        requests:
          storage: 1Gi
    # -- Static provisioning
    # When 'persistentVolumeClaim.create' is 'false', then this value can be used to define 
    # a standard Kubernetes volume that will be used for the local-home volume(s). If not defined, 
    # then an 'emptyDir' volume is utilised. Having provisioned a 'PersistentVolume', specify the
    # bound 'persistentVolumeClaim.claimName' for the 'customVolume' object. Additional detail:
    # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/examples/storage/aws/SHARED_STORAGE.md
    customVolume: {}
    # persistentVolumeClaim:
    #   claimName: "<pvc>" 
    
    # -- Specifies the path in the Jira container to which the local-home volume will be mounted.
    mountPath: "/var/atlassian/application-data/jira"
    
  # -- A volume for shared-home is required by Jira to effectively operate in multi-node environment
  sharedHome:
    # -- Dynamic provisioning. Additional detail: 
    # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/examples/storage/aws/LOCAL_STORAGE.md
    persistentVolumeClaim:
      # -- If 'true', then a 'PersistentVolumeClaim' and 'PersistentVolume' will be dynamically 
      # created for shared-home based on the 'StorageClassName' supplied below.
      create: false
      # -- Specifies the name of the 'StorageClass' that should be used for the shared-home volume claim.
      storageClassName:
      # -- Specifies the standard Kubernetes resource requests and/or limits for the shared-home volume claims.
      resources:
        requests:
          storage: 1Gi
    # -- Static provisioning
    # When 'persistentVolumeClaim.create' is 'false', then this value can be used to define 
    # a standard Kubernetes volume that will be used for the shared-home volume. If not defined, 
    # then an 'emptyDir' volume is utilised. (i.e. unshared). Having provisioned a 'PersistentVolume', 
    # specify the bound 'persistentVolumeClaim.claimName' for the 'customVolume' object. Additional detail:
    # https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/examples/storage/aws/SHARED_STORAGE.md
    customVolume: {}
    # persistentVolumeClaim:
    #   claimName: "<pvc>"
    
    # -- Specifies the path in the Jira container to which the shared-home volume will be mounted.
    mountPath: "/var/atlassian/application-data/shared-home"
    # -- Specifies the sub-directory of the shared-home volume that will be mounted in to the Jira container.
    subPath:
    nfsPermissionFixer:
      # -- If 'true', this will alter the shared-home volume's root directory so that Jira can write to it.
      # This is a workaround for a Kubernetes bug affecting NFS volumes: 
      # https://github.com/kubernetes/examples/issues/260
      enabled: false
      # -- The path in the initContainer where the shared-home volume will be mounted
      mountPath: "/shared-home"
      # -- By default, the fixer will change the group ownership of the volume's root directory to match the Jira
      # container's GID (2001), and then ensures the directory is group-writeable. If this is not the desired behaviour,
      # command used can be specified here.
      command:
  # -- Defines additional volumes that should be applied to all Jira pods.
  # Note that this will not create any corresponding volume mounts;
  # those needs to be defined in jira.additionalVolumeMounts
  additional: []
  
# - Ingress configuration (OPTIONAL) ####################################################################################
# To make the Atlassian product available from outside of the Kubernetes cluster an Ingress 
# Controller should be pre-provisioned. With this in place the configuration below can be used
# to configure an appropriate Ingress Resource. Additional detail:
# https://github.com/atlassian-labs/data-center-helm-charts/blob/master/docs/CONFIGURATION.md#ingress
ingress:
  # -- Set to 'true' if an Ingress Resource should be created. This depends on a 
  # pre-provisioned Ingress Controller being available. 
  create: false
  # -- Set to 'true' if the Ingress Resource is to use the Kubernetes 'ingress-nginx' 
  # controller - https://kubernetes.github.io/ingress-nginx/.
  # This will populate the Ingress Resource with annotations for the Kubernetes 
  # ingress-nginx controller. Set to 'false' if a different controller is to be used, in 
  # which case the appropriate annotations for that controller must to be specified below 
  # under 'ingress.annotations'.
  nginx: true
  # -- The max body size to allow. Requests exceeding this size will result
  # in an 413 error being returned to the client.
  maxBodySize: 250m
  # -- The fully-qualified hostname (FQDN) of the Ingress Resource. Traffic coming in on 
  # this hostname will be routed by the Ingress Resource to the appropriate backend Service's
  host: 
  # -- The base path for the Ingress Resource. 
  # For example '/jira'. Based on a 'ingress.host' value of 'company.k8s.com' this would result 
  # in a URL of 'company.k8s.com/jira'
  path: "/"
  # -- The custom annotations that should be applied to the Ingress Resource 
  # when NOT using the Kubernetes ingress-nginx controller.
  annotations: {}
  # -- Set to 'true' if browser communication with the application should be TLS (HTTPS) enforced.
  https: true
  # -- The name of the Kubernetes Secret that contains the TLS private key and corresponding 
  # certificate. When utilised, TLS termination occurs at the ingress point where traffic to 
  # the Service and its Pods is in plaintext. 
  #
  # Usage is optional, and depends on your use case. The Ingress Controller itself can also 
  # be configured with a TLS secret for all Ingress Resources.
  # Additional detail:
  # https://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets
  # https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
  tlsSecretName:

# - Jira configuration (OPTIONAL) #######################################################################################
jira:
  service:
    # -- The port on which the Jira Kubernetes Service will listen
    port: 80
    # -- The type of Kubernetes service to use for Jira
    type: ClusterIP
    # -- The Tomcat context path that Jira will use. The ATL_TOMCAT_CONTEXTPATH will be set automatically
    contextPath:
  # -- Enable or disable security context in StatefulSet template spec. Enabled by default with UID 2001.
  # -- Disable when deploying to OpenShift, unless anyuid policy is attached to a service account
  securityContext:
    enabled: true
    # -- The GID used by the Jira docker image
    gid: "2001"

  ports:
    # -- The port on which the Jira container listens for HTTP traffic
    http: 8080
    ehcache: 40001
    ehcacheobject: 40011 
  readinessProbe:
    # -- The initial delay (in seconds) for the Jira container readiness probe, after which the probe 
    # will start running.
    initialDelaySeconds: 10
    # -- How often (in seconds) the Jira container readiness probe will run
    periodSeconds: 5
    # -- The number of consecutive failures of the Jira container readiness probe before the pod fails 
    # readiness checks.
    failureThreshold: 30

  accessLog:
    # -- The path within the Jira container where the local-home volume should be mounted in order to 
    # capture access logs.
    mountPath: "/opt/atlassian/jira/logs"
    # -- The subdirectory within the local-home volume where access logs should be stored.
    localHomeSubPath: "log"

  clustering:
    # -- Set to 'true' if Data Center clustering should be enabled
    # This will automatically configure cluster peer discovery between cluster nodes.
    enabled: false

  license:
    # -- The name of the Kubernetes Secret that contains the Jira license key.
    # If specified, then the license will be automatically populated during Jira setup.
    # Otherwise, it will need to be provided via the browser after initial startup.
    # Example of creating a Kubernetes secret:
    # 'kubectl create secret generic <secret-name> --from-literal=license-key=<license> 
    # Additional detail:
    # https://kubernetes.io/docs/concepts/configuration/secret/#opaque-secrets
    secretName:
    # -- The key in the Kubernetes Secret that contains the Jira license key
    secretKey: license-key

  resources:
    jvm:
      # -- JVM memory arguments below are based on the defaults defined for the Jira docker 
      # container. Additional detail:
      # https://bitbucket.org/atlassian-docker/docker-atlassian-jira/src/master/#markdown-header-memory-heap-size
      #
      # -- The maximum amount of heap memory that will be used by the Jira JVM
      maxHeap: "768m"
      # -- The minimum amount of heap memory that will be used by the Jira JVM
      minHeap: "384m"
      # -- The memory reserved for the Jira JVM code cache
      reservedCodeCache: "512m"
    # -- Specifies the standard Kubernetes resource requests and/or limits for the Jira 
    # container. It is important that if the memory resources are specified here, they 
    # must allow for the size of the Jira JVM. That means the maximum heap size, the reserved 
    # code cache size, plus other JVM overheads, must be accommodated. Allowing for 
    # (maxHeap+codeCache)*1.5 would be an example.
    container:
    #  limits:
    #    cpu: "1"
    #    memory: "2G"
      requests:
        cpu: "2" # -- If changing the cpu value update additional JVM arg 'ActiveProcessorCount' below
        memory: "2G"

  # -- Specifies a list of additional arguments that can be passed to the Jira JVM, e.g. 
  # system properties.
  additionalJvmArgs:
    # -- The value defined for ActiveProcessorCount should correspond to that provided 
    # for 'container.requests.cpu'. Additional detail:
    # https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE
    - -XX:ActiveProcessorCount=2

  # -- Specifies a list of additional Java libraries that should be added to the Jira container.
  # Each item in the list should specify the name of the volume that contains the library, 
  # as well as the name of the library file within that volume's root directory. Optionally, a 
  # subDirectory field can be included to specify which directory in the volume contains the library file.
  additionalLibraries: []
  #  - volumeName:
  #    subDirectory:
  #    fileName:

  # -- Specifies a list of additional Jira plugins that should be added to the Jira container.
  # These are specified in the same manner as the additionalLibraries field, but the files will be loaded
  # as bundled plugins rather than as libraries.
  additionalBundledPlugins: []
  #  - volumeName:
  #    subDirectory:
  #    fileName:

  # -- Defines any additional volumes mounts for the Jira container.
  # These can refer to existing volumes, or new volumes can be defined in volumes.additional.
  additionalVolumeMounts: []

  # -- Defines any additional environment variables to be passed to the Jira container.
  # See https://hub.docker.com/r/atlassian/jira-software for supported variables.
  additionalEnvironmentVariables: []

# - Fluentd configuration (OPTIONAL) #####################################################################################
# Jira log collection and aggregation can be enabled using Flunetd. This config assumes an existing ELK stack has
# been stood up and is available.
# https://www.fluentd.org/
fluentd:
  # -- Set to 'true' if the Fluentd sidecar (DaemonSet) should be added to each pod
  enabled: false
  # -- Set to 'true' if a custom config should be used for Fluentd. If enabled this config must 
  # supplied via the 'fluentdCustomConfig' property below.
  customConfigFile: false
  # -- Custom fluent.conf file
  fluentdCustomConfig: {}
  # fluent.conf: |
    # <source>
    #   @type tail
    #   <parse>
    #   @type multiline
    #   format_firstline /\d{4}-\d{1,2}-\d{1,2}/
    #   </parse>
    #   path /opt/atlassian/jira/logs/access_log.*
    #   pos_file /tmp/jiralog.pos
    #   tag jira-access-logs
    # </source>

  # -- The Fluentd sidecar image
  imageName: fluent/fluentd-kubernetes-daemonset:v1.11.5-debian-elasticsearch7-1.2
  # -- The port on which the Fluentd sidecar will listen
  httpPort: 9880
  elasticsearch:
    # -- Set to 'true' if Fluentd should send all log events to an Elasticsearch service.
    enabled: true
    # -- The hostname of the Elasticsearch service that Fluentd should send logs to.
    hostname: elasticsearch
    # -- The prefix of the Elasticsearch index name that will be used
    indexNamePrefix: jira
  # -- Specify custom volumes to be added to Fluentd container (e.g. more log sources)
  extraVolumes: []
  # - name: local-home
  #   mountPath: /opt/atlassian/jira/logs
  #   subPath: log
  #   readOnly: true
  
# -  Misc. configuration (OPTIONAL) #####################################################################################

# -- Custom annotations that will be applied to all Jira pods
podAnnotations: {}
#  "name": "value"

# -- Standard Kubernetes node-selectors that will be applied to all Jira pods
nodeSelector: {}

# -- Standard Kubernetes tolerations that will be applied to all Jira pods
tolerations: []

# -- Standard Kubernetes affinities that will be applied to all Jira pods
affinity: {}

# -- Additional container definitions that will be added to all Jira pods
additionalContainers: []

# -- Additional initContainer definitions that will be added to all Jira pods
additionalInitContainers: []

# -- Additional labels that should be applied to all resources
additionalLabels: {}

# -- Additional existing ConfigMaps and Secrets not managed by Helm that should be 
# mounted into service container. Configuration details below (camelCase is important!):
# 'name'      - References existing ConfigMap or secret name.
# 'type'      - 'configMap' or 'secret'
# 'key'       - The file name.
# 'mountPath' - The destination directory in a container.
# VolumeMount and Volumes are added with this name and index position, for example; 
# custom-config-0, keystore-2
additionalFiles: []
#  - name: custom-config
#    type: configMap
#    key: log4j.properties
#    mountPath:  /var/atlassian
#  - name: custom-config
#    type: configMap
#    key: web.xml
#    mountPath: /var/atlassian
#  - name: keystore
#    type: secret
#    key: keystore.jks
#    mountPath: /var/ssl
